#ifndef RELATIONAL_OPERATOR_HPP
# define RELATIONAL_OPERATOR_HPP

# include "utils.hpp"

/*namespace ft
{
	template<typename T, typename Allocator > 
	bool operator==( const ft::vector<T,Allocator> & lhs, const ft::vector<T,Allocator> & rhs )
	{
		int i;

		i = 0;
		if (lhs.size() == rhs.size())
		{
			while (i < lhs.size())
			{
				if (lhs[i] != rhs[i])
					return (FAILURE);
				i++;
			}
		}
		else
			return (FAILURE);
		return (SUCCESS);
	}

	template<typename T, typename Allocator >
	bool operator!=( const ft::vector<T,Allocator> & lhs, const ft::vector<T,Allocator> & rhs )
	{
		return (!(rhs == lhs));
	}

	template<typename T, typename Allocator >
	bool operator<( const ft::vector<T,Allocator> & lhs, const ft::vector<T,Allocator> & rhs ) 
	{
		return (lhs < rhs);
	}

	template<typename T, typename Allocator >
	bool operator<=( const ft::vector<T,Allocator> & lhs, const ft::vector<T,Allocator> & rhs ) 
	{
		return (!(lhs < rhs));
	}

	template<typename T, typename Allocator >
	bool operator>( const ft::vector<T,Allocator> & lhs, const ft::vector<T,Allocator> & rhs ) 
	{
		return (lhs > rhs);
	}

	template<typename T, typename Allocator >
	bool operator>=( const ft::vector<T,Allocator> & lhs, const ft::vector<T,Allocator> & rhs ) 
	{
		return (!(lhs > rhs));
	}
}
*/
#endif